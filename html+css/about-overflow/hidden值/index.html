<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .scrollOut {
            width: 200px;
            height: 200px;
            overflow: hidden;
        }
        
        .scrollContent {
            width: 400px;
            height: 400px;
        }
    </style>
</head>
<body>
    <div class="scrollOut">
        <div class="scrollContent">
            hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现hidden内容可以以编程的方式滚动（例如，通过设置 scrollLeft 等属性的值或 scrollTo() 方法）, 因此该元素仍然是一个滚动的容器。
对于这个你能给出一段代码实现
        </div>
    </div>

    <script>
        let scrollOut = document.querySelector('.scrollOut')
        // 何为编程滚动？就是用代码让他滚动多少px再呈现出来。
        // scrollOut.scrollLeft = 100

        // scrollOut.scrollTop = 200

        scrollOut.scrollTo(100, 200)

        let a = []
        console.log(a)
    </script>
</body>
</html>